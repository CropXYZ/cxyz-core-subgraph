// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class GameState extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("isPaused", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GameState entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GameState entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GameState", id.toString(), this);
    }
  }

  static load(id: string): GameState | null {
    return changetype<GameState | null>(store.get("GameState", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get isPaused(): boolean {
    let value = this.get("isPaused");
    return value!.toBoolean();
  }

  set isPaused(value: boolean) {
    this.set("isPaused", Value.fromBoolean(value));
  }
}

export class Plot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("season", Value.fromBigInt(BigInt.zero()));
    this.set("width", Value.fromBigInt(BigInt.zero()));
    this.set("height", Value.fromBigInt(BigInt.zero()));
    this.set("tileArea", Value.fromBigInt(BigInt.zero()));
    this.set("baseSpeed", Value.fromBigInt(BigInt.zero()));
    this.set("baseYield", Value.fromBigInt(BigInt.zero()));
    this.set("plotType", Value.fromString(""));
    this.set("countClears", Value.fromBigInt(BigInt.zero()));
    this.set("countDeathClears", Value.fromBigInt(BigInt.zero()));
    this.set("countHarvests", Value.fromBigInt(BigInt.zero()));
    this.set("amountStaked", Value.fromBigInt(BigInt.zero()));
    this.set("timeStartStaked", Value.fromBigInt(BigInt.zero()));
    this.set("timeReadyDelta", Value.fromBigInt(BigInt.zero()));
    this.set("timeExpiredDelta", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Plot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Plot entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Plot", id.toString(), this);
    }
  }

  static load(id: string): Plot | null {
    return changetype<Plot | null>(store.get("Plot", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get width(): BigInt {
    let value = this.get("width");
    return value!.toBigInt();
  }

  set width(value: BigInt) {
    this.set("width", Value.fromBigInt(value));
  }

  get height(): BigInt {
    let value = this.get("height");
    return value!.toBigInt();
  }

  set height(value: BigInt) {
    this.set("height", Value.fromBigInt(value));
  }

  get tileArea(): BigInt {
    let value = this.get("tileArea");
    return value!.toBigInt();
  }

  set tileArea(value: BigInt) {
    this.set("tileArea", Value.fromBigInt(value));
  }

  get baseSpeed(): BigInt {
    let value = this.get("baseSpeed");
    return value!.toBigInt();
  }

  set baseSpeed(value: BigInt) {
    this.set("baseSpeed", Value.fromBigInt(value));
  }

  get baseYield(): BigInt {
    let value = this.get("baseYield");
    return value!.toBigInt();
  }

  set baseYield(value: BigInt) {
    this.set("baseYield", Value.fromBigInt(value));
  }

  get plotType(): string {
    let value = this.get("plotType");
    return value!.toString();
  }

  set plotType(value: string) {
    this.set("plotType", Value.fromString(value));
  }

  get countClears(): BigInt {
    let value = this.get("countClears");
    return value!.toBigInt();
  }

  set countClears(value: BigInt) {
    this.set("countClears", Value.fromBigInt(value));
  }

  get countDeathClears(): BigInt {
    let value = this.get("countDeathClears");
    return value!.toBigInt();
  }

  set countDeathClears(value: BigInt) {
    this.set("countDeathClears", Value.fromBigInt(value));
  }

  get countHarvests(): BigInt {
    let value = this.get("countHarvests");
    return value!.toBigInt();
  }

  set countHarvests(value: BigInt) {
    this.set("countHarvests", Value.fromBigInt(value));
  }

  get stakedCrop(): string | null {
    let value = this.get("stakedCrop");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set stakedCrop(value: string | null) {
    if (!value) {
      this.unset("stakedCrop");
    } else {
      this.set("stakedCrop", Value.fromString(<string>value));
    }
  }

  get amountStaked(): BigInt {
    let value = this.get("amountStaked");
    return value!.toBigInt();
  }

  set amountStaked(value: BigInt) {
    this.set("amountStaked", Value.fromBigInt(value));
  }

  get timeStartStaked(): BigInt {
    let value = this.get("timeStartStaked");
    return value!.toBigInt();
  }

  set timeStartStaked(value: BigInt) {
    this.set("timeStartStaked", Value.fromBigInt(value));
  }

  get timeReadyDelta(): BigInt {
    let value = this.get("timeReadyDelta");
    return value!.toBigInt();
  }

  set timeReadyDelta(value: BigInt) {
    this.set("timeReadyDelta", Value.fromBigInt(value));
  }

  get timeExpiredDelta(): BigInt {
    let value = this.get("timeExpiredDelta");
    return value!.toBigInt();
  }

  set timeExpiredDelta(value: BigInt) {
    this.set("timeExpiredDelta", Value.fromBigInt(value));
  }
}

export class Crop extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("addressMapping", Value.fromString(""));
    this.set("growthTimeTable", Value.fromString(""));
    this.set("plotType", Value.fromString(""));
    this.set("elementName", Value.fromString(""));
    this.set("elementNameHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Crop entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Crop entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Crop", id.toString(), this);
    }
  }

  static load(id: string): Crop | null {
    return changetype<Crop | null>(store.get("Crop", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get addressMapping(): string {
    let value = this.get("addressMapping");
    return value!.toString();
  }

  set addressMapping(value: string) {
    this.set("addressMapping", Value.fromString(value));
  }

  get growthTimeTable(): string {
    let value = this.get("growthTimeTable");
    return value!.toString();
  }

  set growthTimeTable(value: string) {
    this.set("growthTimeTable", Value.fromString(value));
  }

  get plotType(): string {
    let value = this.get("plotType");
    return value!.toString();
  }

  set plotType(value: string) {
    this.set("plotType", Value.fromString(value));
  }

  get elementName(): string {
    let value = this.get("elementName");
    return value!.toString();
  }

  set elementName(value: string) {
    this.set("elementName", Value.fromString(value));
  }

  get elementNameHash(): Bytes {
    let value = this.get("elementNameHash");
    return value!.toBytes();
  }

  set elementNameHash(value: Bytes) {
    this.set("elementNameHash", Value.fromBytes(value));
  }
}

export class YieldConfig extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("isActive", Value.fromBoolean(false));
    this.set("baseYield", Value.fromBigInt(BigInt.zero()));
    this.set("plotType", Value.fromString(""));
    this.set("minYield", Value.fromBigInt(BigInt.zero()));
    this.set("maxYield", Value.fromBigInt(BigInt.zero()));
    this.set("width", Value.fromBigInt(BigInt.zero()));
    this.set("height", Value.fromBigInt(BigInt.zero()));
    this.set("tileArea", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save YieldConfig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save YieldConfig entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("YieldConfig", id.toString(), this);
    }
  }

  static load(id: string): YieldConfig | null {
    return changetype<YieldConfig | null>(store.get("YieldConfig", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    return value!.toBoolean();
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }

  get baseYield(): BigInt {
    let value = this.get("baseYield");
    return value!.toBigInt();
  }

  set baseYield(value: BigInt) {
    this.set("baseYield", Value.fromBigInt(value));
  }

  get plotType(): string {
    let value = this.get("plotType");
    return value!.toString();
  }

  set plotType(value: string) {
    this.set("plotType", Value.fromString(value));
  }

  get minYield(): BigInt {
    let value = this.get("minYield");
    return value!.toBigInt();
  }

  set minYield(value: BigInt) {
    this.set("minYield", Value.fromBigInt(value));
  }

  get maxYield(): BigInt {
    let value = this.get("maxYield");
    return value!.toBigInt();
  }

  set maxYield(value: BigInt) {
    this.set("maxYield", Value.fromBigInt(value));
  }

  get width(): BigInt {
    let value = this.get("width");
    return value!.toBigInt();
  }

  set width(value: BigInt) {
    this.set("width", Value.fromBigInt(value));
  }

  get height(): BigInt {
    let value = this.get("height");
    return value!.toBigInt();
  }

  set height(value: BigInt) {
    this.set("height", Value.fromBigInt(value));
  }

  get tileArea(): BigInt {
    let value = this.get("tileArea");
    return value!.toBigInt();
  }

  set tileArea(value: BigInt) {
    this.set("tileArea", Value.fromBigInt(value));
  }
}

export class GrowthTimeTable extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("isActive", Value.fromBoolean(false));
    this.set("crop", Value.fromString(""));
    this.set("deltaNothingToStart", Value.fromBigInt(BigInt.zero()));
    this.set("deltaStartToEarly", Value.fromBigInt(BigInt.zero()));
    this.set("deltaEarlyToMature", Value.fromBigInt(BigInt.zero()));
    this.set("deltaMatureToExpire", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GrowthTimeTable entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GrowthTimeTable entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GrowthTimeTable", id.toString(), this);
    }
  }

  static load(id: string): GrowthTimeTable | null {
    return changetype<GrowthTimeTable | null>(store.get("GrowthTimeTable", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    return value!.toBoolean();
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }

  get crop(): string {
    let value = this.get("crop");
    return value!.toString();
  }

  set crop(value: string) {
    this.set("crop", Value.fromString(value));
  }

  get deltaNothingToStart(): BigInt {
    let value = this.get("deltaNothingToStart");
    return value!.toBigInt();
  }

  set deltaNothingToStart(value: BigInt) {
    this.set("deltaNothingToStart", Value.fromBigInt(value));
  }

  get deltaStartToEarly(): BigInt {
    let value = this.get("deltaStartToEarly");
    return value!.toBigInt();
  }

  set deltaStartToEarly(value: BigInt) {
    this.set("deltaStartToEarly", Value.fromBigInt(value));
  }

  get deltaEarlyToMature(): BigInt {
    let value = this.get("deltaEarlyToMature");
    return value!.toBigInt();
  }

  set deltaEarlyToMature(value: BigInt) {
    this.set("deltaEarlyToMature", Value.fromBigInt(value));
  }

  get deltaMatureToExpire(): BigInt {
    let value = this.get("deltaMatureToExpire");
    return value!.toBigInt();
  }

  set deltaMatureToExpire(value: BigInt) {
    this.set("deltaMatureToExpire", Value.fromBigInt(value));
  }
}

export class PlotType extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("name", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PlotType entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save PlotType entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("PlotType", id.toString(), this);
    }
  }

  static load(id: string): PlotType | null {
    return changetype<PlotType | null>(store.get("PlotType", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }
}

export class AddressMapping extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("tokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("addressNameHash", Value.fromBytes(Bytes.empty()));
    this.set("addressName", Value.fromString(""));
    this.set("isActive", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AddressMapping entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save AddressMapping entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("AddressMapping", id.toString(), this);
    }
  }

  static load(id: string): AddressMapping | null {
    return changetype<AddressMapping | null>(store.get("AddressMapping", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    return value!.toBytes();
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get addressNameHash(): Bytes {
    let value = this.get("addressNameHash");
    return value!.toBytes();
  }

  set addressNameHash(value: Bytes) {
    this.set("addressNameHash", Value.fromBytes(value));
  }

  get addressName(): string {
    let value = this.get("addressName");
    return value!.toString();
  }

  set addressName(value: string) {
    this.set("addressName", Value.fromString(value));
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    return value!.toBoolean();
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }
}

export class Pool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("tokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("tokenTrackedAmount", Value.fromBigInt(BigInt.zero()));
    this.set("tokenReserveAmount", Value.fromBigInt(BigInt.zero()));
    this.set("goldTrackedAmount", Value.fromBigInt(BigInt.zero()));
    this.set("goldReserveAmount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Pool entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Pool", id.toString(), this);
    }
  }

  static load(id: string): Pool | null {
    return changetype<Pool | null>(store.get("Pool", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    return value!.toBytes();
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get tokenTrackedAmount(): BigInt {
    let value = this.get("tokenTrackedAmount");
    return value!.toBigInt();
  }

  set tokenTrackedAmount(value: BigInt) {
    this.set("tokenTrackedAmount", Value.fromBigInt(value));
  }

  get tokenReserveAmount(): BigInt {
    let value = this.get("tokenReserveAmount");
    return value!.toBigInt();
  }

  set tokenReserveAmount(value: BigInt) {
    this.set("tokenReserveAmount", Value.fromBigInt(value));
  }

  get goldTrackedAmount(): BigInt {
    let value = this.get("goldTrackedAmount");
    return value!.toBigInt();
  }

  set goldTrackedAmount(value: BigInt) {
    this.set("goldTrackedAmount", Value.fromBigInt(value));
  }

  get goldReserveAmount(): BigInt {
    let value = this.get("goldReserveAmount");
    return value!.toBigInt();
  }

  set goldReserveAmount(value: BigInt) {
    this.set("goldReserveAmount", Value.fromBigInt(value));
  }
}

export class TransactionFlow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockIndex", Value.fromBigInt(BigInt.zero()));
    this.set("pool", Value.fromString(""));
    this.set("counterParty", Value.fromBytes(Bytes.empty()));
    this.set("isGoldInbound", Value.fromBoolean(false));
    this.set("flowIn", Value.fromString(""));
    this.set("flowOut", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TransactionFlow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TransactionFlow entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TransactionFlow", id.toString(), this);
    }
  }

  static load(id: string): TransactionFlow | null {
    return changetype<TransactionFlow | null>(store.get("TransactionFlow", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockIndex(): BigInt {
    let value = this.get("blockIndex");
    return value!.toBigInt();
  }

  set blockIndex(value: BigInt) {
    this.set("blockIndex", Value.fromBigInt(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get counterParty(): Bytes {
    let value = this.get("counterParty");
    return value!.toBytes();
  }

  set counterParty(value: Bytes) {
    this.set("counterParty", Value.fromBytes(value));
  }

  get isGoldInbound(): boolean {
    let value = this.get("isGoldInbound");
    return value!.toBoolean();
  }

  set isGoldInbound(value: boolean) {
    this.set("isGoldInbound", Value.fromBoolean(value));
  }

  get flowIn(): string {
    let value = this.get("flowIn");
    return value!.toString();
  }

  set flowIn(value: string) {
    this.set("flowIn", Value.fromString(value));
  }

  get flowOut(): string {
    let value = this.get("flowOut");
    return value!.toString();
  }

  set flowOut(value: string) {
    this.set("flowOut", Value.fromString(value));
  }
}

export class TokenFlow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("blockIndex", Value.fromBigInt(BigInt.zero()));
    this.set("pool", Value.fromString(""));
    this.set("counterParty", Value.fromBytes(Bytes.empty()));
    this.set("tokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("isDirectionIntoPool", Value.fromBoolean(false));
    this.set("isGold", Value.fromBoolean(false));
    this.set("tokenAmount", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenFlow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TokenFlow entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TokenFlow", id.toString(), this);
    }
  }

  static load(id: string): TokenFlow | null {
    return changetype<TokenFlow | null>(store.get("TokenFlow", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockIndex(): BigInt {
    let value = this.get("blockIndex");
    return value!.toBigInt();
  }

  set blockIndex(value: BigInt) {
    this.set("blockIndex", Value.fromBigInt(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get counterParty(): Bytes {
    let value = this.get("counterParty");
    return value!.toBytes();
  }

  set counterParty(value: Bytes) {
    this.set("counterParty", Value.fromBytes(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    return value!.toBytes();
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get isDirectionIntoPool(): boolean {
    let value = this.get("isDirectionIntoPool");
    return value!.toBoolean();
  }

  set isDirectionIntoPool(value: boolean) {
    this.set("isDirectionIntoPool", Value.fromBoolean(value));
  }

  get isGold(): boolean {
    let value = this.get("isGold");
    return value!.toBoolean();
  }

  set isGold(value: boolean) {
    this.set("isGold", Value.fromBoolean(value));
  }

  get tokenAmount(): BigInt {
    let value = this.get("tokenAmount");
    return value!.toBigInt();
  }

  set tokenAmount(value: BigInt) {
    this.set("tokenAmount", Value.fromBigInt(value));
  }
}
